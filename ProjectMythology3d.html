<!DOCTYPE html>
<html data-wf-page="61c5e06d4c32b4d376aaf502" data-wf-site="603fe89ec4bbcece7ee6a53a" lang="en">

<head>
  <meta charset="utf-8" />
  <title>Negotiated Intelligence | 4 Layer Scene</title>
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=603fe89ec4bbcece7ee6a53a" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>

  <style>
    *,
    *::after,
    *::before {
      box-sizing: border-box;
    }

    html {
      background: #030303;
    }

    body {
      margin: 0;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      scrollbar-width: none;
      overscroll-behavior: none;
    }

    canvas {
      left: 0;
      position: fixed;
      top: 0;
      z-index: 1;
    }

    ::-webkit-scrollbar {
      display: none;
    }

    .statlines {
      font-family: "Segoe UI", Verdana, sans-serif;
      color: #b9b8b8;
      z-index: 99;
      line-height: 1.5;
      right: 2vw;
      text-align: right;
      bottom: 4vw;
      position: fixed;
      font-size: 0.7rem;
      max-width: 250px;
    }

    .statlines a {
      color: #fff;
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <div class="statlines">
    <div class="statline"><span><i><b>
            <a href="https://slitrobo.notion.site/Mythology-2025-Negotiated-Intelligence-2825a9a9e41b8041aeacc0eef7e361f8" target="_blank">
              Mythology </a>
          </b></i></span></div>
    <div class="statline">30 audiovisual pieces</div>
    <div class="statline">
      Slitrobo
    </div>
    <div class="statline">2025</div>
  </div>

  <canvas id="hero-threejs"></canvas>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.152.2';
    import {
      OrbitControls
    } from 'https://esm.sh/three@0.152.2/examples/jsm/controls/OrbitControls.js';

    const offset = -2;
    // Layer configurations
    const layers = [{
        type: 'image',
        name: 'layer1',
        src: 'assets/img/mytho/concept.png',
        x: offset,
        y: 0,
        z: 0,
        z_target: 5,
        scaleX: 4.2,
        scaleY: 2.5,
        scaleZ: 2.5,
        opacity: 0.5
      },
      {
        type: 'video',
        name: 'layer2',
        src: 'https://camlab-cave-dance.oss-cn-hongkong.aliyuncs.com/negotiated-intelligence/creative_divergence.mp4',
        x: offset,
        y: 0,
        z: 0,
        z_target: 10,
        scaleX: 4.2,
        scaleY: 2.8,
        scaleZ: 2.8,
        opacity: 0.7
      },
      {
        type: 'image',
        name: 'layer3',
        src: 'assets/img/mytho/generations.png',
        x: offset,
        y: 0,
        z: 0,
        z_target: 15,
        scaleX: 3.0,
        scaleY: 3.0,
        scaleZ: 3.0,
        opacity: 0.6
      },
      {
        type: 'video',
        name: 'layer4',
        src: 'https://camlab-cave-dance.oss-cn-hongkong.aliyuncs.com/negotiated-intelligence/9x9_19-27.mp4',
        x: -5,
        y: 0,
        z: 0,
        z_target: 20,
        scaleX: 3.2,
        scaleY: 3.2,
        scaleZ: 3.2,
        opacity: 0.8
      }
    ];

    const layerMeshes = [];
    const layerStates = [];

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 500, 4000);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(window.innerWidth > 497 ? -19 : 24, 10, window.innerWidth > 497 ? 35 : 56);

    const renderer = new THREE.WebGLRenderer({
      canvas: document.querySelector('#hero-threejs'),
      antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Lights
    const pointLight = new THREE.PointLight(0xffffff);
    pointLight.position.set(5, 5, 5);
    const ambientLight = new THREE.AmbientLight(0xffffff);
    scene.add(pointLight, ambientLight);

    const controls = new OrbitControls(camera, renderer.domElement);

    // Create layers
    layers.forEach((config, index) => {
      layerStates[index] = {
        animated: false,
        config: config
      };

      if (config.type === 'image') {
        createImageLayer(config, index);
      } else if (config.type === 'video') {
        createVideoLayer(config, index);
      }
    });

    function createImageLayer(config, index) {
      const textureLoader = new THREE.TextureLoader();
      const materials = [
        new THREE.MeshPhongMaterial({
          opacity: config.opacity,
          transparent: true,
          color: 0x000000
        }),
        new THREE.MeshPhongMaterial({
          opacity: config.opacity,
          transparent: true,
          color: 0x000000
        }),
        new THREE.MeshPhongMaterial({
          opacity: config.opacity,
          transparent: true,
          color: 0x000000
        }),
        new THREE.MeshPhongMaterial({
          opacity: config.opacity,
          transparent: true,
          color: 0x000000
        }),
        new THREE.MeshPhongMaterial({
          opacity: config.opacity,
          transparent: true,
          map: textureLoader.load(config.src)
        }),
        new THREE.MeshPhongMaterial({
          opacity: config.opacity,
          transparent: true,
          map: textureLoader.load(config.src)
        }),
      ];

      const geometry = new THREE.BoxGeometry(3, 3, 0.01);
      const mesh = new THREE.Mesh(geometry, materials);
      mesh.scale.set(config.scaleX, config.scaleY, config.scaleZ);
      mesh.position.set(config.x, config.y, config.z);
      mesh.userData = {
        layerIndex: index,
        layerType: 'image'
      };

      scene.add(mesh);
      layerMeshes[index] = mesh;
    }

    function createVideoLayer(config, index) {
      const video = document.createElement('video');
      video.src = config.src;
      video.crossOrigin = 'anonymous';
      video.loop = true;
      video.muted = true;
      video.playsInline = true;

      video.addEventListener('loadedmetadata', () => {
        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.format = THREE.RGBAFormat;

        const materials = [
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            color: 0x000000
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            color: 0x000000
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            color: 0x000000
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            color: 0x000000
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            map: videoTexture
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            map: videoTexture
          }),
        ];

        const geometry = new THREE.BoxGeometry(3, 3, 0.01);
        const mesh = new THREE.Mesh(geometry, materials);
        mesh.scale.set(config.scaleX, config.scaleY, config.scaleZ);
        mesh.position.set(config.x, config.y, config.z);
        mesh.userData = {
          layerIndex: index,
          layerType: 'video',
          targetOpacity: config.opacity
        };

        scene.add(mesh);
        layerMeshes[index] = mesh;

        video.play().catch(e => {
          console.log('Video autoplay failed:', e);
          document.addEventListener('click', () => video.play().catch(console.error), {
            once: true
          });
        });
      });

      video.load();
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
    //
    // const pos = `Camera: x:${camera.position.x.toFixed(2)}, y:${camera.position.y.toFixed(2)}, z:${camera.position.z.toFixed(2)}`;
    //       console.log(pos);
    //


      // Animate all layers
      layerMeshes.forEach((mesh, index) => {
        if (!mesh || layerStates[index].animated) return;

        const config = layerStates[index].config;

        // Move layer along z-axis
        if (mesh.position.z < config.z_target) {
          mesh.position.z += 0.05;
        }

        // For video layers, fade in opacity
        if (config.type === 'video' && mesh.userData.targetOpacity) {
          for (let i = 4; i <= 5; i++) {
            if (mesh.material[i].opacity < mesh.userData.targetOpacity) {
              mesh.material[i].opacity += 0.005;
            }
          }

          // Check if animation complete
          if (mesh.position.z >= config.z_target && mesh.material[4].opacity >= mesh.userData.targetOpacity) {
            layerStates[index].animated = true;
          }
        } else {
          // For image layers, just check z position
          if (mesh.position.z >= config.z_target) {
            layerStates[index].animated = true;
          }
        }
      });

      renderer.render(scene, camera);
    }

    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>
