<!DOCTYPE html>
<html data-wf-page="61c5e06d4c32b4d376aaf502" data-wf-site="603fe89ec4bbcece7ee6a53a" lang="en">

<head>
  <meta charset="utf-8" />
  <title>Negotiated Intelligence | The Wrong Biennale 7th Edition</title>
  <meta content="Negotiated Intelligence" name="description" />
  <meta content="Negotiated Intelligence" property="og:title" />
  <meta content="Negotiated Intelligence" property="og:description" />
  <meta property="og:type" content="website" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <link href="base.css" rel="stylesheet" type="text/css" />
  <link href="assets/img/favicon.png" rel="shortcut icon" type="image/x-icon" />
  <link href="assets/img/favicon.png" rel="apple-touch-icon" />
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=603fe89ec4bbcece7ee6a53a" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/gsap.min.js"></script>

  <script type="text/javascript">
    ! function(o, c) {
      var n = c.documentElement,
        t = " w-mod-";
      n.className += t + "js", ("ontouchstart" in o || o.DocumentTouch && c instanceof DocumentTouch) && (n.className += t + "touch")
    }(window, document);
  </script>

  <style>
    *,
    *::after,
    *::before {
      box-sizing: border-box;
    }

    html {
      background: #030303;
    }

    body {
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: subpixel-antialiased;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-overflow-scrolling: touch;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      overscroll-behavior: none;
    }

    .content {
      position: relative;
      z-index: 2;
    }

    #hero-threejs {
      cursor: pointer;
    }

    /*Disable Text Selection */
    @media (min-width: 991px) {
      * {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
    }

    input,
    textarea {
      -webkit-user-select: text;
      -khtml-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    /*Remove Scrollbar */
    ::-webkit-scrollbar {
      -ms-overflow-style: none;
      display: none;
      overflow: -moz-scrollbars-none;
      scrollbar-width: none;
      -ms-overflow-style: none;
      -ms-overflow-style: -ms-autohiding-scrollbar;
    }

    .grid-w {
      display: none;
    }

    .underline-style {
      text-underline-offset: 0.3rem;
      text-decoration-thickness: 1px;
    }

    .blend_back {
      background-blend-mode: luminosity;
      background-color: #030303;
      opacity: 0.1;
      display: block;
    }

    canvas {
      left: 0;
      position: fixed;
      top: 0;
      z-index: 1;
    }

    [data-animation="slider"],
    [data-animation="slider"] .collection-list {
      display: inline-block;
      width: auto !important;
      white-space: nowrap;
    }

    [data-animation="slider-item"] {
      display: inline-block !important;
      height: 38vw;
      position: relative;
      width: 55vw;
    }

    [data-animation="slider-item"] img {
      border: 2px solid #bbb9b94a;
      border-radius: 18px;
      position: absolute;
      object-fit: cover;
      left: 0;
      top: 0;
      height: 100%;
      width: calc(100% - 2vw);
    }

    .menu {
      height: 100vh;
      height: calc(var(--vh, 1vh) * 100);
    }

    @media (max-width: 991px) {
      [data-animation="slider-item"] {
        width: 90vw;
      }

      [data-animation="slider-item"] img {
        border-width: 1px;
        border-radius: 5px;
      }
    }

    .loader {
      display: block;
    }
  </style>

  <style>
    .dataset .h-h2.desc {
      font-size: 1.5rem;
      line-height: 1.3;
      font-weight: 300;
      border-bottom: 1px solid #ddd;
      padding: 8px;
    }

    thead {
      background-color: #585858;
      color: white;
      font-weight: 300;
    }

    th,
    td {
      border-bottom: 1px solid #ddd;
      padding: 8px;
    }

    table {
      border-collapse: collapse;
      border-top: 2px solid black;
      border-bottom: 2px solid black;
    }


    .hero.home,
    .wait {
      height: 100vh;
      display: none;
      /* height: calc(var(--vh, 1vh) * 100); */
    }


    .statlines {
      font-family: "Segoe UI", Verdana, sans-serif;
      overflow-y: scroll;
      color: #b9b8b8;
      z-index: 99;
      line-height: 1.5;
      right: 2vw;
      text-align: right;
      bottom: 4vw;
      position: fixed;
      font-size: 0.7rem;
      max-width: 250px;
    }
  </style>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q1RLJMGX8P"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'G-Q1RLJMGX8P');
  </script>
</head>

<body class="body" data-ix="pre-loader">
  <div class="gradient-embed w-embed">
    <style>
      .gradient {
        -webkit-text-fill-color: transparent;
        -webkit-background-clip: text;
      }

      .blend {
        mix-blend-mode: difference;
      }
    </style>
  </div>

  <main data-template="home" class="content demo">
    <div class="hero home">
      <div data-w-id="53ee3c76-c537-5088-f0d4-fc00e8f8c98a" class="wait-bar">
        <div class="outer hero-t" style="line-height: 150%">
          <div class="text disclaimer load" style="font-size: 12px">
          </div>
        </div>
        <div class="progress-bar">
          <div class="progress-side"></div>
          <div data-w-id="59520e50-2513-aecd-1a28-ea8f307e866f" class="progress-face"></div>
          <div class="progress-text">
            <div class="text-block-2">Loading</div>
          </div>
        </div>
      </div>
      <div class="loader"></div>
      <script type="importmap">
        {
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js"
  }
}
</script>

      <script type="module">
        import * as THREE from 'https://esm.sh/three@0.152.2';
        import {
          OrbitControls
        } from 'https://esm.sh/three@0.152.2/examples/jsm/controls/OrbitControls.js';
        import {
          EffectComposer
        } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
        import {
          RenderPass
        } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';

        let composer, effectSobel;
        let animated_drawing, animated_secondDrawing, animated_wire;
        let animated_drawing_clicked, animated_secondDrawing_clicked, animated_wire_clicked;
        let mural, drawing, secondDrawing, wire;
        let hoveredObject = null;
        let muralOutline, drawingOutline, secondDrawingOutline;

        // Constants
        const Z_offset = 0;
        let mural_x = 2,
          mural_y = 0,
          mural_z = -5,
          mural_scale = 5;
        let mural_scaleX = 4;
        let drawing_x = 0,
          drawing_y = 0,
          drawing_z = 0,
          drawing_z_target = 3,
          drawing_scale = 5;
        let drawing_scaleX = 3;

        let secondDrawing_x = 0,
          secondDrawing_y = 0,
          secondDrawing_z = 10,
          secondDrawing_z_target = 15,
          secondDrawing_scale = 2.8;
        let secondDrawing_scaleX = 4.5;
        let wire_x = 0,
          wire_y = -4,
          wire_z = -4,
          wire_z_target = 18,
          wire_scale = 40;

        // File paths
        const SCENE_BACKGROUND = 'textures/dunhuang/amo_data_bg_dimmed_black.png';
        const MURAL = 'assets/img/silence/Doc.png';
        const DRAWING = 'assets/img/silence/ProcessInverted.png';
        const SECOND_DRAWING = 'assets/img/silence/Final.png';

        const OUTLINE_ON_MOUSEPOINT = false;
        let selectedObjects = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 500, 4000);

        const clock = new THREE.Clock();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(screen.width > 497 ? 3.5 : 12, 9, screen.width > 497 ? 27 : 28); 

        const renderer = new THREE.WebGLRenderer({
          canvas: document.querySelector('#hero-threejs'),
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);

        // Lights
        const pointLight = new THREE.PointLight(0xffffff);
        pointLight.position.set(5, 5, 5);
        const ambientLight = new THREE.AmbientLight(0xffffff);
        scene.add(pointLight, ambientLight);

        const controls = new OrbitControls(camera, renderer.domElement);

        // Mural Image
        const muralTexture = new THREE.TextureLoader().load(MURAL);
        mural = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 0.05), new THREE.MeshBasicMaterial({
          map: muralTexture
        }));
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        mural.scale.set(mural_scaleX, mural_scale, mural_scale);
        mural.position.set(mural_x, mural_y, mural_z);

        // Add userData to identify this as the mural layer
        mural.userData = {
          isMuralLayer: true,
          originalEmissive: 0x000000,
          isInteractive: true
        };

        scene.add(mural);

        // Create outline for mural
        const muralEdges = new THREE.EdgesGeometry(mural.geometry);
        const muralLineMaterial = new THREE.LineBasicMaterial({ 
          color: 0xffff00, 
          linewidth: 3,
          transparent: true,
          opacity: 0
        });
        muralOutline = new THREE.LineSegments(muralEdges, muralLineMaterial);
        muralOutline.scale.set(
          mural.scale.x * 1.015, 
          mural.scale.y * 1.015, 
          mural.scale.z * 1.015
        );
        muralOutline.position.copy(mural.position);
        muralOutline.rotation.copy(mural.rotation);
        scene.add(muralOutline);

        // First Drawing Image
        const drawingloader = new THREE.TextureLoader();
        const opacity = 0.8;
        const drawingCubeMaterials = [
          new THREE.MeshPhongMaterial({
            opacity: opacity,
            transparent: true,
            map: drawingloader.load('textures/dunhuang/black.jpg')
          }),
          new THREE.MeshPhongMaterial({
            opacity: opacity,
            transparent: true,
            map: drawingloader.load('textures/dunhuang/black.jpg')
          }),
          new THREE.MeshPhongMaterial({
            opacity: opacity,
            transparent: true,
            map: drawingloader.load('textures/dunhuang/black.jpg')
          }),
          new THREE.MeshPhongMaterial({
            opacity: opacity,
            transparent: true,
            map: drawingloader.load('textures/dunhuang/black.jpg')
          }),
          new THREE.MeshPhongMaterial({
            opacity: opacity,
            transparent: true,
            map: drawingloader.load(DRAWING)
          }),
          new THREE.MeshPhongMaterial({
            opacity: opacity,
            transparent: true,
            map: drawingloader.load(DRAWING)
          }),
        ];
        const geometry = new THREE.BoxGeometry(3, 3, 0.01);
        drawing = new THREE.Mesh(geometry, drawingCubeMaterials);
        drawing.scale.set(drawing_scaleX, drawing_scale, drawing_scale);
        scene.add(drawing);
        drawing.position.set(drawing_x, drawing_y, drawing_z);
        
        drawing.userData = {
          isDrawingLayer: true,
          isInteractive: true
        };

        // Create outline for drawing layer
        const drawingEdges = new THREE.EdgesGeometry(drawing.geometry);
        const drawingLineMaterial = new THREE.LineBasicMaterial({ 
          color: 0xffff00, 
          linewidth: 3,
          transparent: true,
          opacity: 0
        });
        drawingOutline = new THREE.LineSegments(drawingEdges, drawingLineMaterial);
        drawingOutline.scale.set(
          drawing.scale.x * 1.015, 
          drawing.scale.y * 1.015, 
          drawing.scale.z * 1.015
        );
        drawingOutline.position.copy(drawing.position);
        drawingOutline.rotation.copy(drawing.rotation);
        scene.add(drawingOutline);

        // Image Layer (replaces video layer)
        const imageLoader = new THREE.TextureLoader();
        const imageTexture = imageLoader.load(SECOND_DRAWING);

        const imageOpacity = 0.9;
        const imageCubeMaterials = [
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            color: 0x000000
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            color: 0x000000
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            color: 0x000000
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            color: 0x000000
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            map: imageTexture
          }),
          new THREE.MeshPhongMaterial({
            opacity: 0,
            transparent: true,
            map: imageTexture
          }),
        ];

        const imageGeometry = new THREE.BoxGeometry(3, 3, 0.01);
        secondDrawing = new THREE.Mesh(imageGeometry, imageCubeMaterials);
        secondDrawing.scale.set(secondDrawing_scaleX, secondDrawing_scale, secondDrawing_scale);
        secondDrawing.position.set(secondDrawing_x, secondDrawing_y, secondDrawing_z);

        secondDrawing.userData = {
          isImageLayer: true,
          isInteractive: true
        };

        scene.add(secondDrawing);

        // Create outline for secondDrawing layer
        const secondDrawingEdges = new THREE.EdgesGeometry(secondDrawing.geometry);
        const secondDrawingLineMaterial = new THREE.LineBasicMaterial({ 
          color: 0xffff00, 
          linewidth: 3,
          transparent: true,
          opacity: 0
        });
        secondDrawingOutline = new THREE.LineSegments(secondDrawingEdges, secondDrawingLineMaterial);
        secondDrawingOutline.scale.set(
          secondDrawing.scale.x * 1.015, 
          secondDrawing.scale.y * 1.015, 
          secondDrawing.scale.z * 1.015
        );
        secondDrawingOutline.position.copy(secondDrawing.position);
        secondDrawingOutline.rotation.copy(secondDrawing.rotation);
        scene.add(secondDrawingOutline);

        window.imageOpacity = imageOpacity;

        if (!animated_drawing_clicked) animated_drawing_clicked = true;
        if (!animated_secondDrawing_clicked) animated_secondDrawing_clicked = true;
        if (!animated_wire_clicked) animated_wire_clicked = true;
        animated_drawing = false;
        animated_secondDrawing = false;
        animated_wire = false;

        // Hover highlighting function
        function resetHoverState(object) {
          if (!object) return;
          
          if (object === mural && muralOutline) {
            muralOutline.material.opacity = 0;
          } else if (object === drawing && drawingOutline) {
            drawingOutline.material.opacity = 0;
          } else if (object === secondDrawing && secondDrawingOutline) {
            secondDrawingOutline.material.opacity = 0;
          }
        }

        function setHoverState(object) {
          if (!object) return;
          
          if (object === mural && muralOutline) {
            muralOutline.material.opacity = 1;
          } else if (object === drawing && drawingOutline) {
            drawingOutline.material.opacity = 1;
          } else if (object === secondDrawing && secondDrawingOutline) {
            secondDrawingOutline.material.opacity = 1;
          }
        }

        // Hover event handler
        function onCanvasHover(event) {
          const rect = renderer.domElement.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(scene.children);

          let newHoveredObject = null;

          for (let i = 0; i < intersects.length; i++) {
            const object = intersects[i].object;
            if (object.userData && object.userData.isInteractive) {
              newHoveredObject = object;
              break;
            }
          }

          if (newHoveredObject !== hoveredObject) {
            if (hoveredObject) {
              resetHoverState(hoveredObject);
            }
            
            hoveredObject = newHoveredObject;
            
            if (hoveredObject) {
              setHoverState(hoveredObject);
              renderer.domElement.style.cursor = 'pointer';
            } else {
              renderer.domElement.style.cursor = 'default';
            }
          }
        }

        // Click event handler
        function onCanvasClick(event) {
          const rect = renderer.domElement.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);

          const intersects = raycaster.intersectObjects(scene.children);

          for (let i = 0; i < intersects.length; i++) {
            const object = intersects[i].object;
            if (object.userData && (object.userData.isMuralLayer)) {
              window.open('ProjectSilence.html', '_blank');
              break;
            }
            if (object.userData && (object.userData.isImageLayer)) {
              window.open('https://margarita-wenzel.com/sounds', '_blank');
              break;
            }
          }
        }

        renderer.domElement.addEventListener('click', onCanvasClick);
        renderer.domElement.addEventListener('mousemove', onCanvasHover);

        // Animation Loop
        function animate() {
          requestAnimationFrame(animate);

          const time = -performance.now() * 0.0003;
          controls.update();

          // First drawing animation
          if (animated_drawing_clicked && !animated_drawing) {
            if (drawing.position.z <= drawing_z_target) {
              drawing.position.z += 0.05;
              if (drawingOutline) {
                drawingOutline.position.z = drawing.position.z;
              }
            } else {
              animated_drawing = true;
            }
          }

          // Image layer animation
          if (secondDrawing && animated_secondDrawing_clicked && !animated_secondDrawing) {
            for (let i = 0; i < secondDrawing.material.length; i++) {
              const material = secondDrawing.material[i];
              if (i === 4 || i === 5) {
                if (material.opacity < (window.imageOpacity || 0.8)) {
                  material.opacity += 0.005;
                }
              } else {
                if (material.opacity < 0.2) {
                  material.opacity += 0.005;
                }
              }
            }

            if (secondDrawing.material[4].opacity >= (window.imageOpacity || 0.8)) {
              animated_secondDrawing = true;
            }
          }

          if (wire && animated_wire_clicked && !animated_wire) {
            const model = wire.children[0];
            if (model.material.opacity <= 1) {
              model.material.opacity = model.material.opacity + 0.01;
              model.traverse(n => {
                if (n.isMesh) {
                  n.castShadow = true;
                  n.receiveShadow = true;
                  if (n.material.map) n.material.map.anisotropy = 1;
                }
              });
            } else {
              animated_wire = true;
            }
          }

          renderer.render(scene, camera);

          if (composer) {
            composer.render();
          }
        }

        animate();
      </script>

      <div class="wait">
        <div class="wait-inner">
          <div class="wait_img-wrap">
            <div data-w-id="e8311aee-d434-6a91-e883-eae45438144d" class="wait_img"></div>
            <div data-w-id="a5f9b580-a290-06a9-c3a9-042380199875" class="wait-overlay"></div>
          </div>
          <div class="wait-content">
            <div class="hero-h1__wrap"><img src="https://chunweb.files.wordpress.com/2022/04/cave220.png" loading="lazy" alt="" class="hero-h1" /></div>
            <div class="hero-sum__wrap"><img src="https://chunweb.files.wordpress.com/2022/04/cave220.png" loading="lazy" alt="" class="hero-sum" /></div>
          </div>
        </div>
      </div>

      <div style="display:none" data-w-id="f9fa3984-c135-a210-c0e8-a4d556d96064" class="hero-row">
        <div class="hero-row-wrapper-rotation">
          <div data-animation="translate" data-animation-speed="-2" class="hero-row-wrapper">
            <div data-w-id="2e0b83a3-2ddc-f8d5-5e66-67b4b7f16c12" class="hero-col">
              <h1 data-w-id="b17efb30-8309-927f-1347-0fd3b6b5f13a" class="h-h1 hero-home"></h1>
            </div>
            <div data-w-id="2b8b4a59-2c0d-d6ad-ded6-c96568e0cdca" class="hero-col center"></div>
            <div data-w-id="fed3734d-7289-44d0-92b9-3110190db00e" class="hero-col right">
            </div>
          </div>
        </div>
      </div>
      <div class="info-img-gradient bottom hr">
        <div class="invert w-embed">
          <style>
            .info-img-gradient.bottom.hr {
              transform: scaleY(-1);
            }

            .hero-row {
              padding-bottom: 5vw;
            }
          </style>
        </div>
      </div>
    </div>

    <div class="statlines">
      <div class="title"></div>
      <div class="table">
        <div class="col">
          <img class="drawing" src="" />
          <div class="table">

            <div class="col" style="margin-top:2vw">
              <div class="col" style="margin-top:2vw">
                <div class="statline"><span><i><b>
                        <a href="https://margarita-wenzel.com/sounds" target="_blank">
                          Silence is not the Absence of Speech </a>

                      </b></i></span></div>
                <div class="statline"><span>
                    One Channel Soundpiece by a Designed Voice
                  </span></div>
                <div class="statline"><span>
                    2025 </span></div>
                <div class="statline"><span>
                    <a href="https://margarita-wenzel.com/
                        " target="_blank">
                      Margarita Wenzel</a>
                  </span></div>
              </div>
            </div>

          </div>
        </div>
      </div>
    </div>

    <canvas id="hero-threejs" style="height: 400px; width:100%"></canvas>

  </main>
  <div class="grid-event w-embed">
    <style>
      .grid-w {
        pointer-events: none;
      }
    </style>
  </div>

  <script>
    const script = fetch('./composition_master_main.js').then(async result => {
      result.text().then(text => {
        const scriptElement = document.createElement('script');
        scriptElement.innerHTML = text;
        document.body.appendChild(scriptElement);
      });
    });

    window.onpageshow = function(event) {
      if (event.persisted) {
        window.location.reload()
      }
    };

    //100vh Fix on Mobile
    let vh = window.innerHeight * 0.01;
    let size = 0;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
    window.addEventListener('resize', () => {
      if (window.innerWidth === size) return;
      size = window.innerWidth;
      let vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    });
  </script>

</body>

</html>